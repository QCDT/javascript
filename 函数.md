---
title:  函数
tags:  函数
notebook:  函数
---

## 函数详解
function 函数：当某些代码片段需要重复执行的时候，我们就可以吧这个代码片段封在一个函数中，方便我们重复调用

### 函数声明和调用
- 声明函数
`
    function name(形参，形参){
        执行代码
    }
`
- 调用函数 `name(实参)`;

### 函数传参
当两个函数，功能相似，只是其中用到的一些数据不一致时，我们可以通过传参，把两个参数合并成一个
- 形参: 在函数声明时，我们会在声明的括号中，定义一些名字，用来接收要传入进来的数据
- 实参：在函数调用的时候，实际要传入函数中的数据

### 参数默认值
在声明形参的时候，我们可以给参数定义一个默认值，如果在调用函数函数的时候，没有传递相应的参数，参数的值，就是我们定义的默认值
`
  function sum(nub = 0,nub2 = 0){
      console.log(nub,nub2);
  }
`
### arguments 不定参
arguments 不定参: 在函数调用的时候，实参的集合
- 下标: 可以通过下标来获取到其中第几个参数
- length：通过length 可以获取到传入的实参的数量
- 类数组:类似于数组，和数组的结构一样，具有下标和length，但是并不支持数组的一系列的操作方法

### 返回值 return
return 返回值:函数执行之后的返回结果
- 每个函数都有返回值，没有定义的话，返回值为 undefined
- 函数中，读到return，之后的代码不执行

### function 的 this 指向
function中，谁调用了这个function，this就指向谁 如下例:
                `
                    function fu(){
                        console.log(this)
                    };
                        document.fn = fn; 
                        document.fn(); // document
                        document.body.f = fn;
                        document.body.f(); // body
                        fn(); // window
                `
### 箭头函数
- 语法:
   - 参数=>返回值
   - (参数1,参数2) => 返回值
   - 参数 => {//执行语句; return 返回值;}
   - (参数1，参数2) => {//执行语句; return 返回值;}
   - ()=>{执行语句}
- 箭头函数中没有 arguments
- 箭头函数本身没有this，其this指向声明时所在的作用域的this

### rest参数
接受函数的剩余参数，把剩余参数放入数组
语法如下:
`
    function fn(参数1，参数2，...rest参数名字){
        console.log(rest参数名字);
    }
`
### 预解析
在js中，每读到一个样式表，就会先进行预解析。js的预解析主要针对两个关键字，是 var 和 function。 预解析完成之后，会一行一行的向下执行代码

#### var的预解析(变量提升)
当js解读到一个样式表(作用域)时，会先把这个样式表的 var 关键字找出来，然后把 var 及 它声明的<font color="orange">变量名</font>，提升至 样式表(作用域)的最前方;

#### function 的预解析
当js解读到一个样式表(作用域)时，会先把这个样式表的 function 关键字, 然后把function 声明的整个函数，提升至样式表(作用域)的前方,跟在 var 之后;

### 作用域
作用域: 一个数据或者说一段代码可以在哪些范围内使用

#### 全局作用域
- 全局变量: 声明在全局(任何局部作用域以外)的变量，在全局任意地方都可以调用和修改
- 变量如果不声明的话，就会变成全局变量
- 加在一些全局对象上的属性或方法,也是可以在全局都进行使用的
- 不建议使用全局变量，会造成全局污染，容易变量命名冲突

#### 函数作用域(局部作用域)
- 我们声明在函数中的变量，以及函数本身的参数，这些数据只能在这个函数内部使用，所以这些叫做这个函数的局部变量
- 在函数中有一个内部属性 [[scope]],当我们执行函数时，就会把声明在这个函数中数据，存入 [[scope]], 在函数中调用数据时 也会从 [[scope]] 查找数据

#### 作用域链
作用域链是一种数据查找规则。我们在调用一条数据时，会先在本作用域内部查找，查找不到的话，就会去父作用域查找，一层一层向上直到找到全局作用域，如果在全局作用域还找不到就报错

#### 闭包
闭包是函数和声明该函数的词法环境组合。
- 形式: 函数中嵌套了一个函数
- 重点: 子级可以访问父级的作用域，但父级不能访问子级的作用域
- 闭包包含自由(未绑定到特定对象)变量，这些变量不是在这个代码块内或者任何全局上下文中定义的（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）